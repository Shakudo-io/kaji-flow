<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>Ultrawork Manifesto | 高产出工程哲学</title>
    <meta name="description" content="一个为开发者和 AI 工程师设计的哲学框架，通过深度专注、原子化执行和 Ultrawork 方法论实现极致生产力。">
    <meta name="keywords" content="ultrawork, 开发者生产力, AI 工程, 深度工作, 技术宣言, oh my opencode, sisyphus">
    <meta name="robots" content="index, follow, max-image-preview:large">
    <link rel="canonical" href="https://ulw.dev/zh/">
    <link rel="alternate" hreflang="en" href="https://ulw.dev/">
    <link rel="alternate" hreflang="ko" href="https://ulw.dev/ko/">
    <link rel="alternate" hreflang="ja" href="https://ulw.dev/ja/">
    <link rel="alternate" hreflang="zh" href="https://ulw.dev/zh/">
    <link rel="alternate" hreflang="es" href="https://ulw.dev/es/">
    <link rel="alternate" hreflang="x-default" href="https://ulw.dev/">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="author" content="Yeongyu Kim">
    <link rel="icon" type="image/png" href="../images/favicon.png">
    <link rel="apple-touch-icon" href="../images/favicon.png">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ulw.dev/zh/">
    <meta property="og:title" content="Ultrawork Manifesto | 高产出工程哲学">
    <meta property="og:description" content="一个为开发者和 AI 工程师设计的哲学框架，通过深度专注、原子化执行和 Ultrawork 方法论实现极致生产力。">
    <meta property="og:image" content="https://ulw.dev/images/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Ultrawork Manifesto - 有意义工作的蓝图">
    <meta property="og:site_name" content="Ultrawork">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@justsisyphus">
    <meta name="twitter:creator" content="@justsisyphus">
    <meta name="twitter:title" content="Ultrawork Manifesto | 高产出工程哲学">
    <meta name="twitter:description" content="一个为开发者和 AI 工程师设计的哲学框架，通过深度专注、原子化执行和 Ultrawork 方法论实现极致生产力。">
    <meta name="twitter:image" content="https://ulw.dev/images/og-image.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <div class="hero-container">
            <img src="../images/hero.png" alt="Ultrawork Hero" class="hero-image">
            <h1 class="hero-title">Ultrawork Manifesto</h1>
        </div>
    </header>

    <main>
        <!-- Section 1 -->
        <section id="human-intervention">
            <h2>人工干预是失败的信号</h2>
            
            <div class="gold-gradient-text bottleneck-text">
                人在回路即瓶颈<br>
                人在回路即瓶颈<br>
                人在回路即瓶颈
            </div>

            <p>试想一下自动驾驶。当人类必须接管方向盘时，这并非一项功能——而是系统的失败。这意味着汽车无法独自应对当前状况。</p>

            <h3>编程又有何不同？</h3>

            <p>当你发现自己正在：</p>
            <ul>
                <li>修复 AI 半成品的代码</li>
                <li>手动修正明显的错误</li>
                <li>一步步引导 Agent 完成任务</li>
                <li>反复澄清相同的需求</li>
            </ul>

            <p>……这不叫“人机协作”。这是 AI 未能履行其职责。</p>

            <p><strong><a href="https://github.com/code-yeongyu/oh-my-opencode" target="_blank" rel="noopener">Oh My OpenCode</a> 正是基于这一前提构建的</strong>：在 Agent 工作期间，人工干预本质上是一个错误的信号。如果系统设计得当，Agent 应当能够独立完成工作，而无需你像保姆一样照看。</p>
        </section>

        <div class="divider">
            <img src="../images/orb-divider.png" alt="Divider">
        </div>

        <!-- Section 2 -->
        <section id="indistinguishable-code">
            <h2>无法区分的代码</h2>

            <p class="highlight-box"><strong>目标：Agent 编写的代码应与高级工程师编写的代码无法区分。</strong></p>

            <p>不是“需要清理的 AI 生成代码”。不是“一个好的起点”。而是真正的、最终的、生产就绪的代码。</p>

            <p>这意味着：</p>
            <ul>
                <li>严格遵循现有的代码库模式</li>
                <li>无需被要求即可进行恰当的错误处理</li>
                <li>编写真正测试核心逻辑的测试用例</li>
                <li>拒绝 AI 垃圾代码（过度设计、不必要的抽象、范围蔓延）</li>
                <li>仅在有价值时添加注释</li>
            </ul>

            <p>如果你能分辨出一次提交是由人类还是 Agent 完成的，那么这个 Agent 就失败了。</p>
        </section>

        <div class="divider">
            <img src="../images/orb-divider.png" alt="Divider">
        </div>

        <!-- Section 3 -->
        <section id="token-cost">
            <h2>Token 成本 vs. 生产力</h2>

            <p><strong>如果能显著提高生产力，较高的 Token 使用量是可以接受的。</strong></p>

            <p>使用更多的 Token 来：</p>
            <ul>
                <li>让多个专业 Agent 并行研究</li>
                <li>在无人工干预的情况下彻底完成工作</li>
                <li>在完成前彻底验证工作</li>
                <li>跨任务积累知识</li>
            </ul>

            <p>……当这意味着 10 倍、20 倍甚至 100 倍的生产力提升时，这是一笔值得的投资。</p>

            <h3>然而：</h3>

            <p>我们不追求无谓的 Token 浪费。系统致力于优化：</p>
            <ul>
                <li>对简单任务使用更便宜的模型（Haiku, Flash）</li>
                <li>避免冗余的探索</li>
                <li>跨会话缓存学习成果</li>
                <li>当收集到足够上下文时停止研究</li>
            </ul>

            <p>Token 效率很重要。但绝不能以牺牲工作质量或人类认知负荷为代价。</p>
        </section>

        <div class="divider">
            <img src="../images/orb-divider.png" alt="Divider">
        </div>

        <!-- Section 4 -->
        <section id="cognitive-load">
            <h2>最小化人类认知负荷</h2>

            <p><strong>人类只需要说出他们想要什么。其余的一切都是 Agent 的工作。</strong></p>

            <p>实现这一点的两种方法：</p>

            <div class="approach-container">
                <div class="approach ultrawork-approach">
                    <h3>方法 1：Ultrawork</h3>
                    <p class="approach-tagline">只需说 "ulw" 然后走开。</p>
                    <p>你说：<code>ulw add authentication</code></p>
                    <p>Agent 自主地：</p>
                    <ul>
                        <li>分析你的代码库模式和架构</li>
                        <li>从官方文档研究最佳实践</li>
                        <li>内部规划实施策略</li>
                        <li>遵循你现有的惯例进行实现</li>
                        <li>使用测试和 LSP 诊断进行验证</li>
                        <li>出错时自我修正</li>
                        <li><strong>坚持攻坚，直到 100% 完成</strong></li>
                    </ul>
                    <p class="approach-summary"><strong>零干预。全自主。只看结果。</strong></p>
                </div>

                <div class="approach prometheus-approach">
                    <h3>方法 2：Prometheus + Atlas</h3>
                    <p class="approach-tagline">当你想要战略控制权时。</p>
                    <p>按 <kbd>Tab</kbd> 切换 Agent 后：<code>add authentication</code></p>
                    <p><strong>Prometheus</strong>（战略规划者）：</p>
                    <ul>
                        <li>通过并行 Agent 进行深度代码库研究</li>
                        <li>用智能的、结合上下文的问题采访你</li>
                        <li>识别边缘情况和架构影响</li>
                        <li>生成带有依赖关系的详细 YAML 工作计划</li>
                    </ul>
                    <p><strong>Atlas</strong>（首席编排者）：</p>
                    <ul>
                        <li>通过 <code>/start-work</code> 执行计划</li>
                        <li>将任务委派给专业 Agent（Oracle, 前端工程师等）</li>
                        <li>管理并行执行波次以提高效率</li>
                        <li>追踪进度，处理失败，确保完成</li>
                    </ul>
                    <p class="approach-summary"><strong>你来架构。Agent 执行。完全透明。</strong></p>
                </div>
            </div>

            <p>在这两种情况下，人类的工作是<strong>表达他们想要什么</strong>，而不是管理如何完成。</p>
        </section>

        <div class="divider">
            <img src="../images/orb-divider.png" alt="Divider">
        </div>

        <!-- Section 5 -->
        <section id="predictable-continuous">
            <h2>可预测，连续性，可委派</h2>

            <p><strong>理想的 Agent 应该像编译器一样工作</strong>：输入 Markdown 文档，输出可工作的代码。</p>

            <h3>可预测 (Predictable)</h3>
            <p>给定相同的输入：</p>
            <ul>
                <li>相同的代码库模式</li>
                <li>相同的需求</li>
                <li>相同的约束</li>
            </ul>
            <p>……输出应该是一致的。不是随机的，不是令人惊讶的，也不是在你未要求的地方“发挥创意”。</p>

            <h3>连续性 (Continuous)</h3>
            <p>工作应能经受住中断：</p>
            <ul>
                <li>会话崩溃？用 <code>/start-work</code> 恢复</li>
                <li>需要离开？进度会被追踪</li>
                <li>多日项目？上下文会被保留</li>
            </ul>
            <p>Agent 维护状态。你不需要。</p>

            <h3>可委派 (Delegatable)</h3>
            <p>就像你可以把任务分配给得力的团队成员并信任他们能搞定一样，你应该能够委派给 Agent。</p>
            <p>这意味着：</p>
            <ul>
                <li>清晰的验收标准，独立验证</li>
                <li>出错时的自我修正行为</li>
                <li>仅在真正需要时升级（给 Oracle，给用户）</li>
                <li>完成工作，而不是“差不多做完了”</li>
            </ul>
        </section>

        <div class="divider">
            <img src="../images/orb-divider.png" alt="Divider">
        </div>

        <!-- Section 6 -->
        <section id="core-loop">
            <h2>核心循环</h2>

            <div class="ascii-art">
人类意图 → Agent 执行 → 验证结果
   ↑                      ↓
   └─────── 最小化 ───────┘
    (仅在真正失败时干预)
            </div>

            <p><a href="https://github.com/code-yeongyu/oh-my-opencode" target="_blank" rel="noopener">Oh My OpenCode</a> 中的一切都是为了让这个循环运转而设计的：</p>

            <table>
                <thead>
                    <tr>
                        <th>功能</th>
                        <th>目的</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Prometheus</td>
                        <td>通过智能访谈提取意图</td>
                    </tr>
                    <tr>
                        <td>Metis</td>
                        <td>在歧义变成 Bug 之前捕捉它们</td>
                    </tr>
                    <tr>
                        <td>Momus</td>
                        <td>在执行前验证计划是否完整</td>
                    </tr>
                    <tr>
                        <td>Orchestrator</td>
                        <td>协调工作，无需人类微观管理</td>
                    </tr>
                    <tr>
                        <td>Todo Continuation</td>
                        <td>强制完成，防止“我做完了”的谎言</td>
                    </tr>
                    <tr>
                        <td>Category System</td>
                        <td>无需人工决策即可路由至最佳模型</td>
                    </tr>
                    <tr>
                        <td>Background Agents</td>
                        <td>并行研究而不阻塞用户</td>
                    </tr>
                    <tr>
                        <td>Wisdom Accumulation</td>
                        <td>从工作中学习，不重复错误</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <div class="divider">
            <img src="../images/orb-divider.png" alt="Divider">
        </div>

        <!-- Section 7 -->
        <section id="future">
            <h2>我们正在构建的未来</h2>

            <p>一个这样的世界：</p>
            <ul>
                <li>人类开发者专注于<strong>构建什么</strong>，而不是<strong>如何</strong>让 AI 去构建它</li>
                <li>代码质量与谁（或什么）编写了它无关</li>
                <li>复杂项目像简单项目一样容易（只是耗时更长）</li>
                <li>“提示词工程”变得像“编译器调试”一样过时</li>
            </ul>

            <p><strong>Agent 应该是隐形的。</strong> 不是说它被隐藏起来了，而是说它自然而然地工作——就像电，像自来水，像互联网。</p>

            <p>你按下开关。灯亮了。你不会去思考电网。</p>

            <p class="final-statement">这就是目标。</p>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <a href="https://github.com/code-yeongyu/oh-my-opencode" class="cta-link" target="_blank" rel="noopener">
                获取 Oh My OpenCode →
            </a>
            <p><strong>just ulw ulw</strong></p>
            
            <nav class="language-selector" aria-label="Language selection">
                <span class="language-selector-label">语言</span>
                <div class="language-links">
                    <a href="../" class="language-link" lang="en">English</a>
                    <a href="../ko/" class="language-link" lang="ko">한국어</a>
                    <a href="../ja/" class="language-link" lang="ja">日本語</a>
                    <a href="./" class="language-link active" lang="zh">简体中文</a>
                    <a href="../es/" class="language-link" lang="es">Español</a>
                </div>
            </nav>
        </div>
    </footer>
</body>
</html>